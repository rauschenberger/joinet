getwd()
setwd("/Volumes/KEY/joinet/analysis")
getwd()
setwd("/Volumes/KEY/joinet")
dir()
#<<start>>
load("results/simulation.RData")
cond <- lapply(loss,length)==2
if(any(!cond)){
warning("At least one error.",call.=FALSE)
grid <- grid[cond,]; loss <- loss[cond]
}
#--- computation time ---
time <- sapply(loss,function(x) unlist(x$time))
#round(sort(colMeans(apply(time,1,function(x) x/time["meta",]))),digits=1)
sort(round(rowMeans(time),digits=1))
#--- average ---
loss <- lapply(loss,function(x) x$loss)
loss
dim(loss)
cond
sum(cond)
mean(cond)
#<<start>>
load("results/simulation.RData")
cond <- lapply(loss,length)==2
if(any(!cond)){
warning("At least one error.",call.=FALSE)
grid <- grid[cond,]; loss <- loss[cond]
}
loss
mean <- sapply(loss,function(x) rowMeans(x))
#--- average ---
loss <- lapply(loss,function(x) x$loss)
loss
length(loss)
sapply(loss,function(x) rowMeans(x))
mean <- sapply(loss,function(x) rowMeans(x))
mean
dim(mean)
mean
prop <- sapply(loss[cond],function(x) rowMeans(100*x/matrix(x["none",],nrow=nrow(x),ncol=ncol(x),byrow=TRUE))[-nrow(x)]) # old (first re-scale, then average)
dim(prop)
rownames(mean)
mean[rownames(mean)!="none",]
mean["none",]
mean
mean["none",]
dim(mean)
matrix(mean["none",],nrow=nrow(mean),ncol=ncol(mean))
matrix(mean["none",],nrow=nrow(mean),ncol=ncol(mean),byrow=TRUE)
test <- mean[rownames(mean)!="none",]/matrix(mean["none",],nrow=nrow(mean)-1,ncol=ncol(mean),byrow=TRUE)
#<<start>>
load("results/simulation.RData")
cond <- lapply(loss,length)==2
if(any(!cond)){
warning("At least one error.",call.=FALSE)
grid <- grid[cond,]; loss <- loss[cond]
}
#--- computation time ---
time <- sapply(loss,function(x) unlist(x$time))
#round(sort(colMeans(apply(time,1,function(x) x/time["meta",]))),digits=1)
sort(round(rowMeans(time),digits=1))
#--- average ---
loss <- lapply(loss,function(x) x$loss)
prop <- sapply(loss[cond],function(x) rowMeans(100*x/matrix(x["none",],nrow=nrow(x),ncol=ncol(x),byrow=TRUE))[-nrow(x)]) # old (first re-scale, then average)
mean <- sapply(loss,function(x) rowMeans(x)) # new (first average)
test <- mean[rownames(mean)!="none",]/matrix(mean["none",],nrow=nrow(mean)-1,ncol=ncol(mean),byrow=TRUE)
prop
test
mean <- sapply(loss,function(x) rowMeans(x)) # new (first average)
test <- 100*mean[rownames(mean)!="none",]/matrix(mean["none",],nrow=nrow(mean)-1,ncol=ncol(mean),byrow=TRUE)
test
prop
cor(test,prop)
prop
test
prop
test
prop
i <- 1; j <- 2
warning(paste("Columns",i,"and",j,"are negatively correlated. Consider using constraint=FALSE."),call.=FALSE)
warning(paste("Columns",i,"and",j,"are negatively correlated. Consider using constraint=FALSE."),call.=FALSE)
?glmnet::glmnet
weight <- c(0,1,0,0,1)
cornet:::.check(x=weight,min=0,max=1,null=TRUE)
cornet:::.check
cornet:::.check(x=weight,type="matrix",min=0,max=1,null=TRUE)
weight
weight <- matrix(c(0,1,0,0,1,1),nrow=2)
cornet:::.check(x=weight,type="matrix",min=0,max=1,null=TRUE)
weight = NULL
cornet:::.check(x=weight,type="matrix",min=0,max=1,null=TRUE)
1/0
pkg <- "/Volumes/KEY/joinet/package"
setwd(dir=pkg)
system("ssh -T git@github.com")
system("git remote origin rauschenberger/joinet.git")
system("git remote rauschenberger/joinet.git")
#system("ssh -T git@github.com")
system("git remote origin rauschenberger/joinet.git")
#system("ssh -T git@github.com")
system("git remote origin github.com/rauschenberger/joinet.git")
#system("ssh -T git@github.com")
system("git remote origin https://github.com/rauschenberger/joinet.git")
system("git remote set-url origin https://rauschenberger:Juncker1419@github.com/rauschenberger/joinet.git")
#system("ssh -T git@github.com")
system("git remote origin https://github.com/rauschenberger/joinet.git")
setwd(pkg)
# new approach (ssh)
system("ssh -T git@github.com")
system("git remote set-url origin git@github.com:rauschenberger/joinet.git")
rm(list=ls())
knitr::opts_chunk$set(echo=TRUE,eval=FALSE)
#setwd("/Volumes/KEY/joinet")
#setwd("C:/Users/armin.rauschenberger/Desktop/joinet")
#source("C:/Users/armin.rauschenberger/Desktop/joinet/joinet/R/functions.R")
#pkgs <- c("devtools","missRanger","mice","mvtnorm","glmnet","earth","spls","MTPS","RMTL","MultivariateRandomForest","mcen","MRCE","remMap","SiER","GPM","MLPUGS","benchmarkme")
#install.packages(pkgs)
#devtools::install_github("rauschenberger/joinet")
#devtools::intall_github("cran/MRCE"); ; devtools::intall_github("cran/remMap")
#install.packages("joinet_0.0.X.tar.gz",repos=NULL,type="source")
#library(joinet)
dir()
getwd()
grid <- list()
grid$rho_x <- c(0.00,0.10,0.30)
grid$rho_b <- c(0.00,0.50,0.90)
delta <- 0.8
grid <- expand.grid(grid)
grid <- rbind(grid,grid,grid)
grid$p <- rep(c(10,500,500),each=nrow(grid)/3)
grid$nzero <- rep(c(5,5,100),each=nrow(grid)/3)
grid <- grid[rep(1:nrow(grid),times=10),]
n0 <- 100; n1 <- 10000
n <- n0 + n1
q <- 3
foldid.ext <- rep(c(0,1),times=c(n0,n1))
loss <- list(); cor <- numeric()
for(i in seq_len(nrow(grid))){
p <- grid$p[i]
set.seed(i)
cat("i =",i,"\n")
#--- features ---
mean <- rep(0,times=p)
sigma <- matrix(grid$rho_x[i],nrow=p,ncol=p)
diag(sigma) <- 1
X <- mvtnorm::rmvnorm(n=n,mean=mean,sigma=sigma)
#--- effects --- (multivariate Gaussian)
mean <- rep(0,times=q)
sigma <- matrix(data=grid$rho_b[i],nrow=q,ncol=q)
diag(sigma) <- 1
beta <- mvtnorm::rmvnorm(n=p,mean=mean,sigma=sigma)
#beta <- 1*apply(beta,2,function(x) x>(sort(x,decreasing=TRUE)[grid$nzero[i]])) # old (either zero or one)
beta <- 1*apply(beta,2,function(x) ifelse(x>sort(x,decreasing=TRUE)[m],x,0)) # new (either zero or non-zero)
#-- effects --- (multivariate binomial)
#sigma <- matrix(grid$rho_b[i],nrow=q,ncol=q); diag(sigma) <- 1
#beta <- bindata::rmvbin(n=p,margprob=rep(grid$prop[i],times=q),bincorr=sigma)
#--- outcomes ---
signal <- scale(X%*%beta)
signal[is.na(signal)] <- 0
noise <- matrix(rnorm(n*q),nrow=n,ncol=q)
Y <- sqrt(delta)*signal + sqrt(1-delta)*noise
# binomial: Y <- round(exp(Y)/(1+exp(Y)))
cors <- stats::cor(Y)
diag(cors) <- NA
cor[i] <- mean(cors,na.rm=TRUE)
#--- holdout ---
alpha.base <- 1*(grid$nzero[i] <= 10) # sparse vs dense
compare <- TRUE
loss[[i]] <- tryCatch(expr=cv.joinet(Y=Y,X=X,family="gaussian",compare=compare,foldid.ext=foldid.ext,alpha.base=alpha.base,alpha.meta=1,times=TRUE),error=function(x) NA)
}
install.packages("mvtnorm")
loss <- list(); cor <- numeric()
for(i in seq_len(nrow(grid))){
p <- grid$p[i]
set.seed(i)
cat("i =",i,"\n")
#--- features ---
mean <- rep(0,times=p)
sigma <- matrix(grid$rho_x[i],nrow=p,ncol=p)
diag(sigma) <- 1
X <- mvtnorm::rmvnorm(n=n,mean=mean,sigma=sigma)
#--- effects --- (multivariate Gaussian)
mean <- rep(0,times=q)
sigma <- matrix(data=grid$rho_b[i],nrow=q,ncol=q)
diag(sigma) <- 1
beta <- mvtnorm::rmvnorm(n=p,mean=mean,sigma=sigma)
#beta <- 1*apply(beta,2,function(x) x>(sort(x,decreasing=TRUE)[grid$nzero[i]])) # old (either zero or one)
beta <- 1*apply(beta,2,function(x) ifelse(x>sort(x,decreasing=TRUE)[m],x,0)) # new (either zero or non-zero)
#-- effects --- (multivariate binomial)
#sigma <- matrix(grid$rho_b[i],nrow=q,ncol=q); diag(sigma) <- 1
#beta <- bindata::rmvbin(n=p,margprob=rep(grid$prop[i],times=q),bincorr=sigma)
#--- outcomes ---
signal <- scale(X%*%beta)
signal[is.na(signal)] <- 0
noise <- matrix(rnorm(n*q),nrow=n,ncol=q)
Y <- sqrt(delta)*signal + sqrt(1-delta)*noise
# binomial: Y <- round(exp(Y)/(1+exp(Y)))
cors <- stats::cor(Y)
diag(cors) <- NA
cor[i] <- mean(cors,na.rm=TRUE)
#--- holdout ---
alpha.base <- 1*(grid$nzero[i] <= 10) # sparse vs dense
compare <- TRUE
loss[[i]] <- tryCatch(expr=cv.joinet(Y=Y,X=X,family="gaussian",compare=compare,foldid.ext=foldid.ext,alpha.base=alpha.base,alpha.meta=1,times=TRUE),error=function(x) NA)
}
i
p <- grid$p[i]
set.seed(i)
cat("i =",i,"\n")
#--- features ---
mean <- rep(0,times=p)
sigma <- matrix(grid$rho_x[i],nrow=p,ncol=p)
diag(sigma) <- 1
X <- mvtnorm::rmvnorm(n=n,mean=mean,sigma=sigma)
#--- effects --- (multivariate Gaussian)
mean <- rep(0,times=q)
sigma <- matrix(data=grid$rho_b[i],nrow=q,ncol=q)
diag(sigma) <- 1
beta <- mvtnorm::rmvnorm(n=p,mean=mean,sigma=sigma)
#beta <- 1*apply(beta,2,function(x) x>(sort(x,decreasing=TRUE)[grid$nzero[i]])) # old (either zero or one)
beta <- 1*apply(beta,2,function(x) ifelse(x>sort(x,decreasing=TRUE)[m],x,0)) # new (either zero or non-zero)
#beta <- 1*apply(beta,2,function(x) x>(sort(x,decreasing=TRUE)[grid$nzero[i]])) # old (either zero or one)
beta <- 1*apply(beta,2,function(x) ifelse(x>sort(x,decreasing=TRUE)[grid$nzero[i]],x,0)) # new (either zero or non-zero)
#--- outcomes ---
signal <- scale(X%*%beta)
signal[is.na(signal)] <- 0
noise <- matrix(rnorm(n*q),nrow=n,ncol=q)
Y <- sqrt(delta)*signal + sqrt(1-delta)*noise
# binomial: Y <- round(exp(Y)/(1+exp(Y)))
cors <- stats::cor(Y)
diag(cors) <- NA
cor[i] <- mean(cors,na.rm=TRUE)
#--- holdout ---
alpha.base <- 1*(grid$nzero[i] <= 10) # sparse vs dense
compare <- TRUE
loss[[i]] <- tryCatch(expr=cv.joinet(Y=Y,X=X,family="gaussian",compare=compare,foldid.ext=foldid.ext,alpha.base=alpha.base,alpha.meta=1,times=TRUE),error=function(x) NA)
loss[[i]]
cv.joinet(Y=Y,X=X,family="gaussian",compare=compare,foldid.ext=foldid.ext,alpha.base=alpha.base,alpha.meta=1,times=TRUE)
library(joinet)
cv.joinet(Y=Y,X=X,family="gaussian",compare=compare,foldid.ext=foldid.ext,alpha.base=alpha.base,alpha.meta=1,times=TRUE)
pkgs <- c("devtools","missRanger","mice","mvtnorm","glmnet","earth","spls","MTPS","RMTL","MultivariateRandomForest","mcen","MRCE","remMap","SiER","GPM","MLPUGS","benchmarkme")
install.packages(pkgs)
install.packages(pkgs)
devtools::intall_github("cran/MRCE")
devtools::install_github("cran/MRCE")
devtools::intall_github("cran/remMap")
devtools::install_github("cran/remMap")
devtools::install_github("cran/MRCE")
?install_github
devtools::install_github("cran/QUIC")
devtools::install_github("cran/MRCE")
